# coding: utf-8

# Generated by flask-sqlacodegen
from sqlalchemy import ARRAY, Boolean, CheckConstraint, Column, DateTime, Float, ForeignKey, Integer, Numeric, String, Table, Text
from sqlalchemy.schema import FetchedValue
from sqlalchemy.orm import relationship
from sqlalchemy.sql.sqltypes import NullType
from flask_sqlalchemy import SQLAlchemy

 # manual changes
from sqlalchemy import event
from geoalchemy2 import Geography
from geoalchemy2 import functions as geo_funcs

from marshmallow_sqlalchemy import ModelConverter
from marshmallow import fields

from datetime import datetime
from api.run import db, ma

# TODO: fix foreign keys - they are uncommented at the moment, because of error
# AttributeError: 'Table' object has no attribute 'JobApplication.Id'


# Code for serialization of Geography field with marshmellow
# https://stackoverflow.com/questions/34894170/difficulty-serializing-geography-column-type-using-sqlalchemy-marshmallow
class GeoConverter(ModelConverter):
    SQLA_TYPE_MAPPING = ModelConverter.SQLA_TYPE_MAPPING.copy()
    SQLA_TYPE_MAPPING.update({
        Geography: fields.Str
    })

class GeographySerializationField(fields.String):
    def _serialize(self, value, attr, obj):
        if value is None:
            return value
        else:
            if attr == 'loc':
                return {'latitude': db.session.scalar(geo_funcs.ST_X(value)), 'longitude': db.session.scalar(geo_funcs.ST_Y(value))}
            else:
                return None

    def _deserialize(self, value, attr, data):
        """Deserialize value. Concrete :class:`Field` classes should implement this method.

        :param value: The value to be deserialized.
        :param str attr: The attribute/key in `data` to be deserialized.
        :param dict data: The raw input data passed to the `Schema.load`.
        :raise ValidationError: In case of formatting or validation failure.
        :return: The deserialized value.

        .. versionchanged:: 2.0.0
            Added ``attr`` and ``data`` parameters.
        """
        if value is None:
            return value
        else:
            if attr == 'loc':
                return ma.WKTGeographyElement('POINT({0} {1})'.format(str(value.get('longitude')), str(value.get('latitude'))))
            else:
                return None

class DBAddress(db.Model):
    __tablename__ = 'Address'

    Id = db.Column(db.Integer, db.Sequence('address_id_seq'), primary_key=True, server_default=db.FetchedValue())
    Street = db.Column(db.Text)
    HouseNumber = db.Column(db.Text)
    PostalCode = db.Column(db.Text)
    State = db.Column(db.Text)

class DBAddressSchema(ma.ModelSchema):
    class Meta:
        model = DBAddress
        sqla_session = db.session


class DBContract(db.Model):
    __tablename__ = 'Contracts'

    Id = db.Column(db.Integer, db.Sequence('contract_id_seq'), primary_key=True, server_default=db.FetchedValue())
    JobApplicationId = db.Column(db.ForeignKey('JobApplications.Id'))
    EmployeeSigned = db.Column(db.DateTime)
    EmployerSigned = db.Column(db.DateTime)
    CreatedAt = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    UpdatedAt = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    #JobApplication = db.relationship('JobApplications', primaryjoin='Contracts.JobApplicationId == JobApplications.Id', backref='contracts')

class DBContractSchema(ma.ModelSchema):
    class Meta:
        model = DBContract
        sqla_session = db.session


class DBEmployeeDocument(db.Model):
    __tablename__ = 'EmployeeDocuments'

    Id = db.Column(db.Integer, db.Sequence('employee_document_id_seq'), primary_key=True, server_default=db.FetchedValue())
    EmployeeId = db.Column(db.ForeignKey('Employees.Id'))
    EmployeeeDocumentType = db.Column(db.Text)
    path = db.Column(db.Text)

    #Employee = db.relationship('Employee', primaryjoin='EmployeeDocuments.EmployeeId == Employee.Id', backref='employee_documents')

class DBEmployeeDocumentSchema(ma.ModelSchema):
    class Meta:
        model = DBEmployeeDocument
        sqla_session = db.session


class DBEmployee(db.Model):
    __tablename__ = 'Employees'

    Id = db.Column(db.Integer, db.Sequence('employee_id_seq'), primary_key=True, server_default=db.FetchedValue())
    UserId = db.Column(db.ForeignKey('Users.Id'))
    AddressId = db.Column(db.ForeignKey('Address.Id'))
    Description = db.Column(db.Text)
    CreatedAt = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    UpdatedAt = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    #Address = db.relationship('Address', primaryjoin='Employees.AddressId == Addres.Id', backref='employees')
    #User = db.relationship('Users', primaryjoin='Employees.UserId == User.Id', backref='employees')

class DBEmployeeSchema(ma.ModelSchema):
    class Meta:
        model = DBEmployee
        sqla_session = db.session


class DBEmployerPicture(db.Model):
    __tablename__ = 'EmployerPictures'

    Id = db.Column(db.Integer, db.Sequence('employer_picture_id_seq'), primary_key=True, server_default=db.FetchedValue())
    EmployerId = db.Column(db.ForeignKey('Employers.Id'))
    path = db.Column(db.Text)

    #Employer = db.relationship('Employers', primaryjoin='EmployerPictures.EmployerId == Employer.Id', backref='employer_pictures')

class DBEmployerPictureSchema(ma.ModelSchema):
    class Meta:
        model = DBEmployerPicture
        sqla_session = db.session


class DBEmployer(db.Model):
    __tablename__ = 'Employers'

    Id = db.Column(db.Integer, db.Sequence('employer_id_seq'), primary_key=True, server_default=db.FetchedValue())
    UserId = db.Column(db.ForeignKey('Users.Id'))
    DefaultPictureId = db.Column(db.ForeignKey('EmployerPictures.Id'))
    CompanyName = db.Column(db.Text)
    Industry = db.Column(db.Text)
    Description = db.Column(db.Text)
    AddressId = db.Column(db.ForeignKey('Address.Id'))
    CreatedAt = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    UpdatedAt = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    #Address = db.relationship('Address', primaryjoin='Employers.AddressId == Address.Id', backref='employers')
    #EmployerPicture = db.relationship('EmployerPictures', primaryjoin='Employers.DefaultPictureId == EmployerPicture.Id', backref='employers')
    #User = db.relationship('User', primaryjoin='Employers.UserId == User.Id', backref='employers')

class DBEmployerSchema(ma.ModelSchema):
    class Meta:
        model = DBEmployer
        sqla_session = db.session

class DBJobApplication(db.Model):
    __tablename__ = 'JobApplications'

    Id = db.Column(db.Integer, db.Sequence('job_application_id_seq'), primary_key=True, server_default=db.FetchedValue())
    JobId = db.Column(db.ForeignKey('Jobs.Id'))
    EmployeeId = db.Column(db.ForeignKey('Employees.Id'))
    EmployerId = db.Column(db.ForeignKey('Employers.Id'))
    EmployeeStatus = db.Column(db.Text)
    EmployerStatus = db.Column(db.Text)
    CreatedAt = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    UpdatedAt = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    #Employee = db.relationship('Employees', primaryjoin='JobApplications.EmployeeId == Employees.Id', backref='job_applications')
    #Employer = db.relationship('Employers', primaryjoin='JobApplications.EmployerId == Employers.Id', backref='job_applications')
    #Job = db.relationship('Job', primaryjoin='JobApplications.JobId == Job.Id', backref='job_applications')

class DBJobApplicationSchema(ma.ModelSchema):
    class Meta:
        model = DBJobApplication
        sqla_session = db.session

class DBJobPicture(db.Model):
    __tablename__ = 'JobPictures'

    Id = db.Column(db.Integer, db.Sequence('job_picture_id_seq'), primary_key=True, server_default=db.FetchedValue())
    JobId = db.Column(db.ForeignKey('Jobs.Id'))
    path = db.Column(db.Text)

    #Job = db.relationship('Jobs', primaryjoin='JobPictures.JobId == Job.Id', backref='job_pictures')

class DBJobPictureSchema(ma.ModelSchema):
    class Meta:
        model = DBJobPicture
        sqla_session = db.session


t_JobPoints = db.Table(
    'JobPoints',
    db.Column('ContractId', db.ForeignKey('Contracts.Id')),
    db.Column('EmployeeId', db.ForeignKey('Employees.Id')),
    db.Column('GivenPoints', db.Integer),
    db.Column('CreatedAt', db.DateTime),
    db.Column('UpdatedAt', db.DateTime)
)



class DBJob(db.Model):
    __tablename__ = 'Jobs'

    Id = db.Column(db.Integer, db.Sequence('job_id_seq'), primary_key=True, server_default=db.FetchedValue())
    EmployerId = db.Column(db.ForeignKey('Employers.Id'))
    DefaultImagePictureId = db.Column(db.ForeignKey('JobPictures.Id'))
    Description = db.Column(db.Text)
    SalaryHourly = db.Column(db.Numeric)
    WorkHoursPerDay = db.Column(db.Numeric)
    WorkDaysPerWeek = db.Column(db.Integer)
    AccommodationAvailable = db.Column(db.Boolean)
    AccommodationCostPerDay = db.Column(db.Numeric)
    WithMeals = db.Column(db.Boolean)
    MealCostPerDay = db.Column(db.Numeric)
    SpokenLanguages = db.Column(db.Text)
    Location = Column(Geography(geometry_type='POINT', srid=4326)) #manual change
    LocationDescription = db.Column(db.Text)
    StartDate = db.Column(db.DateTime)
    EndDate = db.Column(db.DateTime)
    SpecialRequirements = db.Column(db.Text)
    Contingent = db.Column(db.Integer)
    IsActive = db.Column(db.Boolean)
    CreatedAt = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    UpdatedAt = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    #JobPicture = db.relationship('JobPictures', primaryjoin='Jobs.DefaultImagePictureId == JobPictures.Id', backref='jobs')
    #Employer = db.relationship('Employers', primaryjoin='Jobs.EmployerId == Employers.Id', backref='jobs')

class DBJobSchema(ma.ModelSchema):
    Location = GeographySerializationField(attribute='Location')
    class Meta:
        model = DBJob
        sqla_session = db.session
        model_converter = GeoConverter

class DBUser(db.Model):
    __tablename__ = 'Users'

    Id = db.Column(db.Integer, db.Sequence('user_id_seq'), primary_key=True) #server_default=db.FetchedValue())
    Login = db.Column(db.Text)
    Password = db.Column(db.Text)
    FirstName = db.Column(db.Text)
    LastName = db.Column(db.Text)
    
    def __repr__(self):
        return '<User %r>' % self.LastName
        #return '<UserId {0}, Login {1}>'.format(self.Id, self.Login)

class DBUserSchema(ma.ModelSchema):
    class Meta:
        model = DBUser
        sqla_session = db.session

# populate test data
@event.listens_for(DBUser.__table__, 'after_create')
def insert_initial_values_user(*args, **kwargs):
    db.session.add(DBUser(Login=u'meister_lampe', Password=u'verysecret', FirstName=u'Hans', LastName=u'Meister'))
    db.session.commit()

@event.listens_for(DBEmployer.__table__, 'after_create')
def insert_initial_values_employer(*args, **kwargs):
    db.session.add(DBEmployer(UserId=1, CompanyName=u'Meister Lampe GmbH', Industry=u'Bäcker', Description=u'Wir backen die besten Semmeln!', AddressId=1))
    db.session.commit()

@event.listens_for(DBAddress.__table__, 'after_create')
def insert_initial_values_address(*args, **kwargs):
    db.session.add(DBAddress(PostalCode=85354, HouseNumber=u'32a', State=u'Deutschland', Street=u'Hinterhof 32'))
    db.session.commit()

# Migrate database
print("migrating database..")
db.create_all()
db.session.commit()